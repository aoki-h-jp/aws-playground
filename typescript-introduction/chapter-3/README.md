# chapter-3

## files
- 3-1-1.ts オブジェクトの宣言
- 3-1-2.ts オブジェクトリテラル
- 3-1-3.ts 文字列リテラルによるプロパティアクセス
- 3-1-4.ts 文字列リテラル内に制御式があるときのプロパティアクセス
- 3-1-5.ts スプレッド演算子
- 3-1-6.ts オブジェクト同士が同じかどうか
- 3-2-1.ts 型注釈付きのオブジェクトの宣言
- 3-2-2.ts 型注釈でのエラー
- 3-2-3.ts type文による型の宣言
- 3-2-4.ts interface文による型の宣言
- 3-2-5.ts 任意のプロパティ名を許容する型
- 3-2-6.ts オプショナルなプロパティの宣言
- 3-2-7.ts 読み取り専用プロパティ
- 3-2-8.ts typeofによる型推論の利用

## memo
オブジェクトについて
- プロパティ名は動的に指定できる
- constで宣言したオブジェクトに別のオブジェクトを再代入することはできないが、中身を書き換えることはできてしまう
- スプレッド構文を使うことでdeepcopyができる (単純にlet foo = barのようにイコールで繋ぐだけだとshallowなcopyになる)、ただしスプレッドしたオブジェクトがネストされている場合は奥の要素はshallowなcopyになる点には注意（標準的なやり方で全部deepcopyはできない）
  
オブジェクトの型について
- type文で型を宣言することができる（これはTypeScript特有）
- あくまで型に別名を付けるだけなので、オブジェクトを宣言してからtype文で型を決めてもいいし、primitiveにも別名をつけれる
- interface文でも同様に型を宣言することができる（ただしオブジェクト型だけ、type文で代用できるので基本はあまり使わないが読めた方がいい）
- プロパティ名が動的に決まる場合はインデックスシグネチャが使える（ただし型安全性を破壊することにつながるので注意深く使う）
- オプショナルなプロパティの追加はプロパティ名の頭に?を付ければいい
- 読み取り専用プロパティにはreadonlyを付けて宣言する、再代入しようとするとエラーになる
- typeofでそのオブジェクトが持つ型を参照できる、また型推論の結果を型として再利用する場合にとても便利だが、そのような場合でもtypeを使っておいた方がいい
- TypeScriptでは部分型は構造的部分型なので、無関係に宣言された2つの型が部分的な関係を持つことがある
- TypeScriptでは<>を使うことで型引数を取れる、型引数を持つ形で宣言した場合は引数を必ず指定する必要がある、型引数を使うことで構造を引き継ぐことができ、より抽象化されたプログラムを書くことができる
